import cv2
import numpy as np
import openslide
import xml.etree.ElementTree as ET

# image numpy.arrays are [Row, Column, Channel] 

def blend_images(slide, heatmap, alpha):

    return cv2.addWeighted(slide, alpha, heatmap, 1-alpha, 0)

#def draw_tumor_contours(slide, 

def gen_color_heatmap(pred_arr, patch_size, cv2_colormap):
#Other colormaps: COLORMAP_ +
#AUTUMN, BONE, JET, WINTER, RAINBOW, OCEAN, SUMMER, SPRING, COOL, HSV, PINK, HOT

    heatmap = gen_grayscale_heatmap(pred_arr, patch_size)

    return cv2.applyColorMap(heatmap, cv2_colormap)


def gen_grayscale_heatmap(pred_arr, patch_size):
# pred_mat is a 2D numpy array containing prediction values, ordered so that preserves the
# relative spatial information of patches.
# patch_size is a single int indicating patch dimensions (assumes length =
# width)

    width, height = pred_arr.shape
    
    # Creates empty template that will be colored depending on prediction
    # value. This array is assumed to be equal to the initial slide
    # image in shape.
    mapping = np.zeros((width * patch_size, height * patch_size), dtype = np.uint8)
    
    # One loop iteration fills pixels corresponding to one patch
    for index, x in np.ndenumerate(pred_arr):
        row_l = patch_size * index[0]
        row_r = patch_size * (index[0] + 1)
        col_t = patch_size * index[1]
        col_b = patch_size * (index[1] + 1)

        # Converts prediction value [0 ~ 1] to grayscale [0 ~ 255]
        mapping[row_l:row_r, col_t:col_b] = round(x * 255)

    return mapping

def parseXML(XML_file, downscale = 1):

# Designed to be compatible with cv2.drawContours

# It may seem weird but this is the structure generated by
# cv2.findContours and also the structure that is expected by
# cv2.drawContours

    '''
    An example of output structure
    
    Type(anns): <class 'list'> 
    
    Type(anns[0]): <class 'numpy.ndarray'> 
    [[[   0    0]]
     [[   0 6579]]
     [[2966 6579]]
     [[2966    0]]]
    
    Type(anns[0][0]): <class 'numpy.ndarray'> 
    [[0 0]]
    
    Type(anns[0][0][0]): <class 'numpy.ndarray'> 
    [0 0]
      
    Type(anns[0][0][0][0]): <class 'numpy.int32'> 
    0
    '''

    root = ET.parse(XML_file).getroot()
    anns = [] # List containing all annotation groups

    for node in root.iter('Annotation'):
        group = []
        for subnode in node.iter('Coordinate'):
            group.append(np.array([np.array((round(float(subnode.get('X')) / downscale), 
                                             round(float(subnode.get('Y')) / downscale)), 
                                             dtype = np.int32)], dtype = np.int32))
        group = np.array(group, dtype = np.int32)
        anns.append(group)

    return anns


# Main for unit testing-----------------------------

if __name__ == '__main__':
    
    TEST_IMG_DIR = '/home/jwwoo/pre-camelyon/slide_images/'
    TEST_IMGS = ['b_1.tif', 'b_9.tif', 'b_10.tif']
    TEST_XMLS = ['b_1.xml', 'b_9.xml', 'b_10.xml']
    PATCH_SIZE = 100
    LEVEL = 5
    ALPHA = 0.5

    TEST_ARR = np.array([[0. , 0. , 0.3, 0.2],
                         [0.6, 0. , 0.1, 0. ],
                         [1. , 0.4, 0. , 0. ]])

    print('Opening slide...\n')
    slide = openslide.OpenSlide(TEST_IMG_DIR + TEST_IMGS[0])

    col, row = slide.level_dimensions[LEVEL]

    img = np.array(slide.read_region((0,0), LEVEL, (col, row)))
    
    print('Generating heatmap...\n')
    heatmap = gen_color_heatmap(TEST_ARR, PATCH_SIZE, cv2.COLORMAP_JET)

    cv2.imwrite('map_color.jpg', heatmap)
    
    #TODO FIX THIS
    print('Overlaying slide with heatmap...\n')
    img = blend_images(slide, heatmap, ALPHA)

    print('Processing XML file for tumor region contours...\n')
    contours = parseXML(TEST_IMG_DIR + TEST_XMLS[0], slide.level_downsamples[LEVEL])
    
    print(type(img))
    # Draws true contours for tumor regions
    cv2.drawContours(img, contours, -1, (0,0,0), 3)

    
    cv2.imwrite('final_map.jpg', img)
    print('Done!')
